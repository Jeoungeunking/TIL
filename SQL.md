# SQL

### 1. RDBMS

### 2. DDL

####		1)CREATE

```sql
CREATE TABLE T_USER(
	ID VARCHAR2(10),
	PWD VARCHAR2(10),
	NAME VARCHAR2(10)
);
```

#### 	2)DROP

```sql
DROP TABLE T_USER;
DELETE FROM T_USER WHERE ID ='id07'; id07인 행을 지운다.
SELECT * FROM T_USER; 모든 행 출력
```

#### 	3)ALTER

```sql
ALTER TABLE T_PRODUCT ADD REGDATE DATE; COLUMN 추가
ALTER TABLE T_PRODUCT DROP COLUMN REGDATE; COLUMN 삭제
ALTER TABLE T_PRODUCT MODIFY (NAME NULL); 변수 형식 수정
ALTER TABLE T_PRODUCT RENAME COLUMN NAME TO UNAME; 변수 이름 수정
ALTER TABLE T_USER ADD PRIMARY KEY(ID); ID를 PK로
ALTER TABLE T_USER MODIFY(PWD NOT NULL); PWD, NAME NULL허용 X 하겠다.
ALTER TABLE T_USER MODIFY(NAME NOT NULL);
ALTER TABLE T_USER MODIFY (NAME UNIQUE); NAME을 UNIQUE하게 (중복X)

ALTER TABLE T_PRODUCT MODIFY (PRICE DEFAULT 1000); 값이 없으면 디폴트값 넣는다.
INSERT INTO T_PRODUCT(ID, NAME, REGDATE) VALUES ('P03','pants3',SYSDATE);
```

```
`unique constraint (DB.SYS_C007091) violated`
```

#### 	4)INSERT

```
INSERT INTO T_USER () VALUES ()
```



#### 	5)UPDATE

```
UPDATE T_USER SER PWD='111',NAME='공말숙'
UPDATE T_USER SET PWD='111',NAME='공말숙' WHERE ID='id03'
```

#### 6)SELECT

```SQL
SELECT ENAME,SAL,DEPTNO AS DNO FROM EMP; DEPTNO를 DNO로 바꿔 출력
SELECT ENAME,SAL*12 AS ASAL,DEPTNO AS DNO FROM EMP; 연봉...
SELECT ENAME,SAL, SAL*12 AS ASAL,DEPTNO AS DNO
FROM EMP;
// JAVA에서 꺼낼때도 바꾼이름으로 꺼낸당.
SELECT ENAME||JOB FROM EMP; 두개 컬럼의 데이터가 붙어서 나온다.
SELECT ENAME || '/' || JOB AS ENAMEJOB FROM EMP; 중간을 나눌 수도 있다.
SELECT DISTINCT(JOB) FROM EMP; 중복 제거된 결과 출력
SELECT DISTINCT(JOB), ENAME FROM EMP; 같이쓰는건 의미 X
SELECT * FROM EMP WHERE JOB = 'MANAGER' AND SAL >2500 
AND HIREDATE >'04/15/1981'
//AND절로 조건을 좀 더 붙일수도 있다.
SELECT * FROM EMP --주석/**/
WHERE JOB = 'MANAGER' AND ENAME LIKE 'C%';
SELECT ENAME, SAL, (SAL*0.87+NVL(COMM,0)*0.88)*12 AS YSAL FROM EMP;
-- NVL(VARIABLE, 0) NULL값이 있으면 0으로 바꿔줌
SELECT ENAME, SAL, (SAL*0.87+NVL(COMM,0)*0.88)*12 AS YSAL FROM EMP
WHERE (SAL*0.87+NVL(COMM,0)*0.88)*12 >30000;
--조건 붙이려면 저거 다 끌어와야됨..
<>: NOT EQUAL
SELECT * FROM EMP WHERE COMM IS NULL; --NULL은 비교연산 불가능. 물어보자ㅎㅎ
SELECT * FROM EMP WHERE COMM IS NOT NULL;

SELECT * FROM EMP WHERE JOB = 'CLERK'
AND( DEPTNO = 10 OR DEPTNO =20); --AND의 우선순위가 높기 때문에 () 적절히 활용하자

SELECT ENAME, SAL FROM EMP ORDER BY SAL DESC;--내림차순
SELECT * FROM EMP WHERE MGR IS NOT NULL ORDER BY MGR,ENAME;
--자동 오름차순. ORDER BY MGR 한 뒤에 ENAME
SELECT TO_CHAR(HIREDATE,'YYYY') --연도만 끄집어내기
-----------
SELECT
WHERE
GROUP BY
ORDER BY
-----------
SELECT ENAME FROM EMP
WHERE DEPTNO =
(SELECT DEPTNO FROM DEPT WHERE LOC='DALLAS')
--쿼리 안의 쿼리-> 서브쿼리!!!
SELECT ENAME, SAL FROM EMP
WHERE SAL > (SELECT AVG(SAL) FROM EMP)--스칼라 서브쿼리 / 하나의 단일한 값

SELECT ENAME, SAL FROM EMP
WHERE SAL > (SELECT AVG(SAL) FROM EMP)
AND DEPTNO IN(SELECT DEPTNO FROM DEPT WHERE LOC IN('DALLAS','CHICAGO'))
-- 두개 이상의 값을 가져오기 때문에 IN 사용

ALTER TABLE ITEM ADD FOREIGN KEY(CATE)
REFERENCES CATEGORY(NO)--ITEM 테이블의 CATE를 CATEGORY테이블의 NO로 만든다.(FK)

SELECT DEPTNO, ENAME, SAL FROM EMP E1
WHERE SAL = 
(SELECT MAX(SAL) FROM EMP
 WHERE DEPTNO != (SELECT DEPTNO FROM DEPT WHERE DNAME = 'ACCOUNTING')
 GROUP BY DEPTNO
 HAVING DEPTNO = E1.DEPTNO)

--java의 this 처럼 사용
---------------
DALLAS 지역에서 근무하는 사람들 중
전체 월급의 평균 보다 많이받는 사람의
 ENAME, JOB, SAL을 출력하시오

SELECT e.ENAME, e.JOB, e.SAL FROM EMP e, DEPT d
WHERE(e.DEPTNO = d.DEPTNO)
AND (d.LOC = 'DALLAS')
AND (e.SAL > (SELECT AVG(SAL) FROM EMP))
ORDER BY ENAME
----------------
CLERK를 제외하고 
각 지역에서 월급을 제일 적게 받는 사람의
LOC, ENAME, JOB, SAL을 출력

SELECT d.LOC, e.ENAME, e.JOB, e.SAL FROM EMP e, DEPT d
WHERE(e.DEPTNO = d.DEPTNO)
AND (SAL = (SELECT MIN(SAL) FROM EMP e2
WHERE(e.DEPTNO = e2.DEPTNO)AND(e2.JOB !='CLERK')))
ORDER BY ENAME
---------------
SELECT d.LOC, e.ENAME, e.HIREDATE FROM EMP e, DEPT d
WHERE 
e.HIREDATE =
(
SELECT MAX(HIREDATE) FROM EMP e2, DEPT d2
WHERE e2.DEPTNO = d.DEPTNO
)

```

### 3. DML

#### 1) SELECT

SELECT 구조

Alias AS

WHERE AND OR NOT

Operation

ORDER BY

#### - FUNCTION

```SQL
SELECT SUM(SAL) AS CNT FROM EMP
SELECT MAX(SAL) AS CNT FROM EMP
SELECT AVG(COMM) AS CNT FROM EMP --그룹함수 사용시 NULL값 제외하고 계산
SELECT ROUND(AVG(NVL(COMM,0)),2) AS CNT FROM EMP --ROUND 반올림, TRUNK 버림
SELECT MIN(SAL),MAX(SAL),SUM(SAL),AVG(SAL) FROM EMP
SELECT MAX(HIREDATE) FROM EMP -- MIN MAX 날짜에 사용 가능
SELECT SUM(SAL),SUM(DISTINCT SAL) FROM EMP --중복된 SAL 빼고 계산
SELECT JOB, SUM(SAL) FROM EMP
GROUP BY JOB -- GROUP BY 함수는 항상 GROUP함수들과 함께 사용.
SELECT DEPTNO, JOB, SUM(SAL)FROM EMP
GROUP BY DEPTNO, JOB
HAVING DEPTNO IN(10,20) AND JOB LIKE '%E%'
--GROUP 함수 쓸때는 조건문 WHERE X HAVING O
--HAVING절에 들어가는 조건은 그룹지은 조건만..!
ORDER BY DEPTNO
--GROUP조건 HAVING / GROUP 이외의 조건 WHERE
CREATE VIEW DEPTSAL(DEPTNO,SALAVG) AS
SELECT DEPTNO, AVG(SAL) FROM EMP
GROUP BY DEPTNO
--VIEW 생성
SELECT * FROM DEPTSAL

CREATE VIEW ORACLE(TOTALAVG) AS
SELECT AVG(SALAVG) FROM DEPTSAL
--VIEW로 또 VIEW 생성
SELECT * FROM ORACLE

DROP VIEW ORACLE
--VIEW 삭제
```



술어

CASE

